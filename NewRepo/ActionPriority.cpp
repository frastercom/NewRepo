#include "ActionPriority.h"
#include <vector>
#include "Math.h"
using namespace std;

vector<string> p;
//
void math()
{
    Math m = Math();
    for (int i = 0; i < p.size(); i++) // пробегаем по элементам вектора, ищем приоритетное действие
    {
        
        if (p.at(i).compare("*") == 0) //если нашли знак умножения
        {
            
            string s1 = p.at(i - 1); //необходимо для преоброзования типа
            string s2 = p.at(i + 1); //необходимо для преоброзования типа
            int p1 = stoi(s1.c_str()); //необходимо для преоброзования типа
            int p2 = stoi(s2.c_str()); //необходимо для преоброзования типа
            int mul = m.math(p1, p.at(i), p2); //выполнение математической операции
            string ms = to_string(mul); //необходимо для преоброзования типа
            p.erase(p.begin() + i - 1); //удаление элемента по индексу в векторе
            p.erase(p.begin() + i - 1); //удаление элемента по индексу в векторе
            p.insert(p.begin() + i - 1, ms); //вставка результата в вектор
            p.erase(p.begin() + i); //удаление элемента по индексу в векторе
            return;
        }
    }
    for (int i = 0; i < p.size(); i++) // пробегаем по элементам вектора, ищем приоритетное действие
    {
        if (p.at(i).compare("/") == 0) //если нашли знак деления
        {
            string s1 = p.at(i - 1); //необходимо для преоброзования типа
            string s2 = p.at(i + 1); //необходимо для преоброзования типа
            int p1 = stoi(s1.c_str()); //необходимо для преоброзования типа
            int p2 = stoi(s2.c_str()); //необходимо для преоброзования типа
            int mul = m.math(p1, p.at(i), p2); //выполнение математической операции
            string ms = to_string(mul); //необходимо для преоброзования типа
            p.erase(p.begin() + i - 1); //удаление элемента по индексу в векторе
            p.erase(p.begin() + i - 1); //удаление элемента по индексу в векторе
            p.insert(p.begin() + i - 1, ms); //вставка результата в вектор
            p.erase(p.begin() + i); //удаление элемента по индексу в векторе
            return;
        }
    }
    for (int i = 0; i < p.size(); i++) // пробегаем по элементам вектора, ищем приоритетное действие
    {
        if (p.at(i).compare("+") == 0) //если нашли знак сложения
        {
            string s1 = p.at(i - 1); //необходимо для преоброзования типа
            string s2 = p.at(i + 1); //необходимо для преоброзования типа
            int p1 = stoi(s1.c_str()); //необходимо для преоброзования типа
            int p2 = stoi(s2.c_str()); //необходимо для преоброзования типа
            int mul = m.math(p1, p.at(i), p2); //выполнение математической операции
            string ms = to_string(mul); //необходимо для преоброзования типа
            p.erase(p.begin() + i - 1); //удаление элемента по индексу в векторе
            p.erase(p.begin() + i - 1); //удаление элемента по индексу в векторе
            p.insert(p.begin() + i - 1, ms); //вставка результата в вектор
            p.erase(p.begin() + i); //удаление элемента по индексу в векторе
            return;
        }
    }
    for (int i = 0; i < p.size(); i++) // пробегаем по элементам вектора, ищем приоритетное действие
    {
        if (p.at(i).compare("-") == 0) //если нашли знак вычитания
        {
            string s1 = p.at(i - 1); //необходимо для преоброзования типа
            string s2 = p.at(i + 1); //необходимо для преоброзования типа
            int p1 = stoi(s1.c_str()); //необходимо для преоброзования типа
            int p2 = stoi(s2.c_str()); //необходимо для преоброзования типа
            int mul = m.math(p1, p.at(i), p2); //выполнение математической операции
            string ms = to_string(mul); //необходимо для преоброзования типа
            p.erase(p.begin() + i - 1); //удаление элемента по индексу в векторе
            p.erase(p.begin() + i - 1); //удаление элемента по индексу в векторе
            p.insert(p.begin() + i - 1, ms); //вставка результата в вектор
            p.erase(p.begin() + i); //удаление элемента по индексу в векторе
            return;
        }
    }
}

int ActionPriority::work(vector<string> param)
{
    p = param;
	while (p.size() > 1)
	{
        math();
	}
}
